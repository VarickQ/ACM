//##点集S内面积最大的三角形###include<iostream>#include<stdio.h>#include<algorithm>#include<cmath>#include<complex>using namespace std;const double inf=1e-8;typedef complex<double> Point;//求两点间的距离double Distance(Point a,const Point b){    return sqrt((a.real()-b.real())*(a.real()-b.real())+        (a.imag()-b.imag())*(a.imag()-b.imag()));}int dbcmp(double tp){    return tp<-inf?-1:tp>inf;}//求矢量叉积double operator ^(Point a,Point b){return imag(conj(a)*b);}Point base; bool compare2(Point a,Point b){    double rea=a-base^b-base;     if(dbcmp(rea)>0)return true;     //如果在同一线上的点距base近的点在前,     //在while循环中除距base最远的点外都将被踢除     else if(dbcmp(rea)==0&&         dbcmp(Distance(a,base)-Distance(b,base))<0)         return true;     else return false;}bool compare1(Point a, Point b){    return a.imag()<b.imag()||(a.imag()==b.imag()&&a.real()<b.real());}//通过矢量叉积求极角关系（ac）(bc)//k > 0 ,ac在bc顺时针方向上//求凸包的顶点，不包括边上的点 int create_convex(int vsize,Point * v,Point *result,Point &base) {    //寻找base点    base=v[0];    int index=0;    for(int i=1;i<vsize;i++)    {        if(compare1(v[i],base))        {  base=v[i];index=i;}    }    swap(v[index],v[0]);    sort(v+1,v+vsize,compare2);    result[0]=v[0];    int k=1;    int pos=0;    while(k<vsize)    {        while(pos>0&&dbcmp(v[k]-result[pos-1]^            result[pos]-result[pos-1])>=0)pos--;//判断是不是入栈        result[++pos]=v[k++];    }    return pos+1;}const int Max=1000010;Point p[Max],re[Max];int main(){    //freopen("1.txt","r",stdin);    int m;    double x,y;    while(scanf("%d",&m)!=EOF)    {        for(int i=0;i<m;i++)        {            scanf("%lf%lf",&x,&y);            p[i]=Point(x,y);        }        int resz=create_convex(m,p,re,base);        //求最远点对的距离        double ans=0;        int j,pos;        re[resz]=re[0];        for(int i=0;i<resz;i++)        {            j=(i+1)%resz;            pos=(i+2)%resz;            while(pos!=i&&(re[j]-re[i]^re[pos]-re[i])<(re[j]-re[i]^re[pos+1]-re[i]))                pos=(pos+1)%resz;            if(pos==i) continue;            int pp=(pos+1)%resz;            while(j!=pp&&pos!=i)            {                ans = max(ans,(re[j]-re[i]^re[pos]-re[i]));                while(pos!=i&&(re[j]-re[i]^re[pos]-re[i])<(re[j]-re[i]^re[pos+1]-re[i]))                    pos=(pos+1)%resz;                j=(j+1)%resz;            }         }        printf("%.2lf\n",ans/2.0);    }}