//hdojAC , POJ CE#include <iostream>#include <stdio.h>#include <stdlib.h>#include <math.h>#include <string.h>#include <algorithm>using namespace std;struct Tree{	int fa,chi,bro,tap,not;	int Max(){		return tap>not?tap:not;	}	void init(){		fa=chi=bro=not=0;	}}tree[6001];void dfs(int idx){	int child;	child = tree[idx].chi;	while(child){		dfs(child);		tree[idx].tap += tree[child].not;		tree[idx].not += tree[child].Max();		child = tree[child].bro;	}}int main(){	int n,i,a,b;	while(scanf("%d",&n) == 1)	{		for(i=1 ; i <= n ; i++){			tree[i].init();			scanf("%d",&tree[i].tap);		}		while(scanf("%d%d",&a,&b)&&(a+b)){			tree[a].fa = b;			tree[a].bro= tree[b].chi;			tree[b].chi= a;		}		for(i=1 ; i <= n ; i++){			if(!tree[i].fa){				dfs(i);				printf("%d\n",tree[i].Max());				break;			}		}	}	return 0;}//POJ AC , hdoj WA#include <iostream>#include <stdio.h>#include <stdlib.h>using namespace std;#define N 6005int n;int dp[N][2],fa[N];//0 for not,1 for takebool visit[N];void dp_dfs(int node){	int i,j;	visit[node]=1;	for(i=1 ; i <= n ; i++)	{		if(!visit[i] && fa[i]==node)		{			dp_dfs(i);			dp[node][1] += dp[i][0];			dp[node][0] += max(dp[i][1],dp[i][0]);		}	}}int main(){	int i,root,c,f;	while(scanf("%d",&n) == 1)	{		memset(dp,0,sizeof(dp));		memset(fa,0,sizeof(fa));		memset(visit,0,sizeof(visit));		for(i=1 ; i <= n ; i++)			scanf("%d",&dp[i][1]);		root = 0;		bool beg = true;		while(scanf("%d %d",&c,&f),c+f>0)		{			fa[c] = f;			if(root==c || beg)				root = f;		}		dp_dfs(root);		printf("%d\n",max(dp[root][0],dp[root][1]));	}    return 0;}