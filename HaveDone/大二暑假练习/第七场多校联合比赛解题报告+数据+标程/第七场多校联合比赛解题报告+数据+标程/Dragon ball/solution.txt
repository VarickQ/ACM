单调队列+DP

设dp[i][j]表示第i批龙珠中取第j个需要花费的最小体力。
dp[i][j] = min{ dp[i-1][k] + abs(pos[i-1][k]-pos[i][j]) } + cost[i][j];
如果枚举k的话总复杂度位m*n*n，会超时。
可以看出若每个状态只由上一层位置在其左边的状态的转移而来的话：  

dp[i][j] = min { dp[i-1][k] + pos[i][j] - pos[i-1][k] } + cost[i][j]
         = min { dp[i-1][k] - pos[i-1][k] } + pos[i][j] + cost[i][j]

dp[i-1][k]-pos[i-1][k]是个确定的值，就是相当于求位置在pos[i][j]左边的上一层状态中值最小的，可以用个单调队列维护。由右边转移来的类似，再处理一遍右边转移来的取最优。
因为要对同一层的点排序，所以总复杂度是m*n*logn。