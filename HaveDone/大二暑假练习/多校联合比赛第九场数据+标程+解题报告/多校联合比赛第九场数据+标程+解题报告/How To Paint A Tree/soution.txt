这是一道treeDP， 设f[i（1~n)][j(0~1)][k(0~1)]，i,j表示把i为根的所有子树给染成j色。k表示i节点现在是否存在存在连接父亲节点的第二种操作。

然后转移目前没有发现更优美的方法，只有手动把所有转移给写下来。

     if(L > 0 && R > 0){ 	//左子树和右子树都存在时

            if(color[w] == j){  	//当当前节点的颜色等于j时

                f[w][j][0] = min(f[L][j][0] + f[R][j][0], 
//这个表示左子树和右子树都染成j色的情况，然后当前节点就不用任何操作了

                                 f[L][1 - j][1] + f[R][1 - j][1] - 1 + 1); 
//这个表示左右子树都是与j相反的颜色而且都存在连接父亲节点的第二种操作，这样情况可以用一次操作二完成左右两边的操作二，这时整棵树都是(1-j)色，然后再用一次 操作一 将整课数变成j色。

剩下的转移基本与上面相同大家仔细推，即可推出。

                 f[w][j][1] = min(f[L][1 - j][0] + f[R][1 - j][0] + 2,
                                 f[L][1 - j][1] + f[R][1 - j][0] + 1,
                                 f[L][1 - j][0] + f[R][1 - j][1] + 1);
            }
            else{
                f[w][j][0] = min(f[L][1 - j][0] + f[R][1 - j][0] + 1,
                                 f[L][j][0] + f[R][j][1],
                                 f[L][j][1] + f[R][j][0],
                                 f[L][j][1] + f[R][j][1] - 1);
                 f[w][j][1] = min(f[L][j][0] + f[R][j][0] + 1,
                                  f[L][j][0] + f[R][j][1],
                                  f[L][j][1] + f[R][j][0]);
         
            }
    }
    else if(L > 0){ //当只存在一课子树时
        for(int j = 0; j < 2; j++){
            if(color[w] == j){
                f[w][j][0] = min(f[L][j][0]);
                f[w][j][1] = min(f[L][j][0] + 1, 
                                 f[L][1 - j][1] + 1);
            }
            else {
                f[w][j][0] = min(f[L][1 - j][0] + 1, 
                                 f[L][j][1]); 
                f[w][j][1] = min(f[L][j][0] + 1,
                                 f[L][j][1]);
            }
        }
    }
    else{
        for(int j = 0; j < 2; j++)
            if(color[w] == j){
                f[w][j][0] = 0;
                f[w][j][1] = 2;
            }
            else {
                f[w][j][0] = 1;
                f[w][j][1] = 1;
            }
    }

    
   f[w][j][0] = min(f[w][j][0], f[w][j][1]);
   
   f[w][j][0] = min(f[w][j][0], f[w][1 - j][0] + 1);
   f[w][j][1] = min(f[w][j][1], f[w][1 - j][1] + 1);
  
   f[w][j][0] = min(f[w][j][0], f[w][j][1]);
