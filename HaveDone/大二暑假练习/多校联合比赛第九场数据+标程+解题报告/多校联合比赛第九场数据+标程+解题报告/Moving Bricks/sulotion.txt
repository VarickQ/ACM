简单状态DP.
需要注意的是,由于耗费的时间是路长的平方,所以一次性取两点的代价并不一定比分两次取小.


每次从building出发
对于当前状态i和当前未纳入状态的点j
t = i | (1<<j);
dp[t] = dp[i] + dist[n][j] + dist[j][n];
对于未纳入状态t的点k
p = t | (1<<k);
dp[k] = dp[i] + dist[n][j] + dist[j][k] + dist[k][n];

关于取点的输出,可以记录当前状态i的前一状态pre[i],两状态取异或即可.每次出发后会取回1~2点 即(Ai1,Ai2)或Ai1
由于各点的序号是不相同的,只需要比较每次出发取到的较小的序号.
将这些点或点对取其中序号较小的作为关键字按升序排序输出即可.